# Построение максимального потока в сети с использованием алгоритма Диница

Этот проект реализует алгоритм Диница для вычисления максимального потока в сети. Основная программа реализована на Python (`dinic.py`) и C++ (`dinic.cpp`) для повышения производительности. Также предоставляется модуль тестирования (`test_dinic.py`) для проверки корректности реализации на Python.

---

## Структура проекта

```
Общая папка/
├── dinic.py           # Основной код алгоритма Диница на Python
├── test_dinic.py      # Код для тестирования реализации на Python
├── dinic.cpp          # Основной код алгоритма Диница на C++
├── input.txt          # Пример входных данных (опционально)
├── README.md          # Описание проекта
```

---

## Используемые файлы

### 1. `dinic.py` (Python)
Основной файл проекта. Реализует алгоритм Диница на Python.

#### Основные функции:

- **`add_edge(u, v, capacity)`**  
  Добавляет ребро с пропускной способностью в граф.

- **`bfs(s, t)`**  
  Выполняет обход в ширину (BFS), строя уровневый граф.

- **`dfs(u, t, flow)`**  
  Выполняет обход в глубину (DFS), находя блокирующие потоки.

- **`max_flow(s, t)`**  
  Вычисляет максимальный поток от истока \( s \) до стока \( t \).

- **`main()`**  
  Обрабатывает входные данные и вызывает вычисление максимального потока.

---

### 2. `test_dinic.py` (Python)
Модуль для тестирования. Использует библиотеку `unittest` для проверки корректности алгоритма.

#### Основные тесты:
- **Пустой граф:** Проверяет поведение при отсутствии рёбер.
- **Граф с одним ребром:** Проверяет, что поток равен пропускной способности.
- **Сложный граф:** Проверяет корректность на графах с циклами и параллельными путями.
- **Большие графы:** Оценивает производительность на графах с большим количеством рёбер.

---

### 3. `dinic.cpp` (C++)
Оптимизированная реализация алгоритма Диница на C++. Подходит для обработки больших графов с высокой производительностью.

#### Основные функции:
- **`add_edge(u, v, capacity)`**  
  Добавляет ребро с пропускной способностью и обратное ребро.

- **`bfs(s, t)`**  
  Выполняет построение уровневого графа (BFS).

- **`dfs(u, t, flow)`**  
  Выполняет поиск блокирующего потока (DFS).

- **`max_flow(s, t)`**  
  Возвращает максимальный поток от истока \( s \) до стока \( t \).

---

## Как запустить проект

### 1. Запуск Python-версии

#### Основная программа:
```bash
python dinic.py
```

#### Пример входных данных:
```plaintext
6 10
0 1 16
0 2 13
1 2 10
1 3 12
2 1 4
2 4 14
3 2 9
3 5 20
4 3 7
4 5 4
0 5
```

Сохраните входные данные в `input.txt` и перенаправьте их в программу:

```bash
python dinic.py < input.txt
```

Ожидаемый вывод:
```plaintext
Максимальный поток: 23
```

---

### 2. Запуск тестов на Python
Для проверки корректности алгоритма выполните:
```bash
python test_dinic.py
```

#### Пример вывода:
```plaintext
...
----------------------------------------------------------------------
Ran 3 tests in 0.001s

OK
```

---

### 3. Запуск C++-версии

#### Компиляция программы:
Скомпилируйте файл `dinic.cpp` с использованием компилятора GCC или другого совместимого компилятора:
```bash
g++ -O2 -std=c++17 dinic.cpp -o dinic
```

#### Запуск программы:
```bash
./dinic < input.txt
```

#### Пример вывода:
```plaintext
Максимальный поток: 23
```

---

## Пример входных данных

```plaintext
6 10
0 1 16
0 2 13
1 2 10
1 3 12
2 1 4
2 4 14
3 2 9
3 5 20
4 3 7
4 5 4
0 5
```

---

## Зависимости

### Для Python
- Python 3.9 или выше
- Библиотека `unittest` (входит в стандартную библиотеку Python)

### Для C++
- Компилятор, поддерживающий стандарт C++17 или выше (например, GCC, Clang, MSVC).

---

## Преимущества реализации на C++

1. **Высокая производительность:** Оптимизированный код подходит для работы с большими графами.
2. **Компактность:** Использование встроенных контейнеров C++ упрощает реализацию.
3. **Универсальность:** Легко интегрируется в проекты, требующие высокой производительности.